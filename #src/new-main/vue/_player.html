<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
<style>
	.chapter-block::-webkit-scrollbar {
		width: 3px;
		height: 3px;
	}

	.chapter-block::-webkit-scrollbar-thumb {
		background: oklch(75% 0.00006 271.152);
	}

	.chapter-block::-webkit-scrollbar-track {
		background: transparent;
		border-radius: 4px;
	}

	.chapter-block {
		scrollbar-face-color: #d9d9d9;
		scrollbar-track-color: transparent;
	}
</style>
<script>
	function calcHeighChapterBlock() {
		let player = document.querySelector('.player-block media-player');
		let chapterBlock = document.querySelectorAll('.chapter-block');
		if (chapterBlock && player) {
			chapterBlock.forEach((element) => {
				element.style.setProperty('--max-height', player.offsetHeight - '75' + 'px');
			});
			if (window.innerWidth < 1200) {
				chapterBlock.forEach((element) => {
					element.style.setProperty('--max-height', 'auto');
				});
			}
		}
	}
	window.addEventListener('resize', () => {
		calcHeighChapterBlock();
	});

	window.addEventListener('load', () => {
		setTimeout(calcHeighChapterBlock, 2000);
	});
</script>
<div id="app">
	<template id="player-template">
		<div class="row">
			<!-- <div class="d-flex justify-content-center mt-5 col-12" :class="[loading ? 'd-block' : 'd-none']">
				<div
					class="spinner-border"
					role="status"
					style="border-color: #b9b9b9; border-right-color: var(--color-gold); width: 3rem; height: 3rem"
				>
					<span class="visually-hidden">Loading...</span>
				</div>
			</div> -->
			<div class="col-12">
				<h2 class="h2" :class="[loading ? 'placeholder placeholder-wave border-20' : '']">{{title}}</h2>
			</div>
			<div class="d-flex align-items-start col-xl-8 col-12">
				<div ref="target" class="player-block border-20 w-100 overflow-hidden" style="z-index: 3"
					:class="[loading ? 'placeholder placeholder-wave' : '']"></div>
			</div>
			<!-- <div>
				<button @click="play">Play</button>
				<button @click="pause">Pause</button>
				<button @click="toggleMute">{{ muted ? 'Unmute' : 'Mute' }}</button>
			</div> -->
			<!-- <div class='mt-3'>
				<b>Таймкоды:</b>
				<ul>
					<li v-for="(tc, idx) in timeCodes" :key="idx">
						<a href="#" @click.prevent="seekTo(tc.time)">
							{{ formatTime(tc.time) }} — {{ tc.label }}
						</a>
					</li>
				</ul>
			</div> -->
			<div class="d-flex mt-4 mt-xl-0 col-xl-4 col-12" :class="[loading ? '' : '']">
				<div class="bg-white-gray px-3 pt-3 pb-2 border-20 w-100">
					<h3 class="mb-0 h3">Главы:</h3>
					<div class="chapter-block d-flex flex-column gap-3 mt-3 pe-2"
						style="--max-height: 356px; overflow-y: auto; max-height: var(--max-height)">
						<div :class="[loading ? 'd-block' : 'd-none']"
							class="d-flex flex-row align-items-center gap-2 transition-3 transition-3 color-black hover-gold">
							<!-- <i class="w-fit-content bi fs-32"
								:class="[idx <= currentChapterIdx ? 'bi-eye-fill color-gold' : 'bi-eye color-gray' ]"></i> -->
							<div class="d-flex flex-row gap-1 p-1 border border-1 border-10 border-gray w-100">
								<div class="py-3 border-20 w-100 placeholder placeholder-wave"></div>
							</div>
						</div>

						<a v-for="(ch, idx) in chapters" :key="idx" href="#"
							class="d-flex flex-row align-items-center gap-2 transition-3 transition-3 color-black hover-gold"
							@click.prevent="seekTo(ch.time)" :class="[loading ? 'invisible' : 'visible']">
							<!-- <i class="w-fit-content bi fs-32"
								:class="[idx <= currentChapterIdx ? 'bi-eye-fill color-gold' : 'bi-eye color-gray' ]"></i> -->
							<div class="d-flex flex-row gap-1 px-3 py-2 border border-1 border-10 border-gray w-100 fs-14"
								:class="[idx <= currentChapterIdx ? 'color-gold' : 'color-black' ]">
								<span>{{ formatTime(ch.time) }} — {{ ch.label }} </span>
							</div>
						</a>
					</div>
				</div>
			</div>
		</div>
	</template>
	<player-component></player-component>
</div>

<script type="module">
	import { VidstackPlayer, VidstackPlayerLayout } from 'https://cdn.vidstack.io/player';

	window.Vue.createApp({
		components: {
			'player-component': {
				template: document.getElementById('player-template').innerHTML,
				data() {
					return {
						player: null,
						muted: false,
						title: 'Sprite Fight',
						duration: 0,
						// timeCodes: [
						// 	{ time: 10, label: 'Вступление' },
						// 	{ time: 42, label: 'Битва начинается' },
						// 	{ time: 75, label: 'Кульминация' },
						// ],
						chapters: [],
						RUSSIAN: {
							Accessibility: 'Особые возможности',
							AirPlay: 'AirPlay',
							Announcements: 'Объявления',
							Audio: 'Аудио',
							Auto: 'Авто',
							Boost: 'Усиление',
							Captions: 'Субтитры',
							Chapters: 'Главы',
							Color: 'Цвет',
							Connected: 'Подключено',
							Connecting: 'Подключение',
							Continue: 'Продолжить',
							Default: 'По умолчанию',
							Disabled: 'Отключено',
							Disconnected: 'Отключено',
							Download: 'Скачать',
							Family: 'Шрифты',
							Font: 'Шрифт',
							Fullscreen: 'Полноэкранный режим',
							LIVE: 'Прямой эфир',
							Loop: 'Повторение',
							Mute: 'Выключить звук',
							Normal: 'Нормальный',
							Off: 'Выключено',
							Opacity: 'Прозрачность',
							Pause: 'Пауза',
							PiP: 'Картинка в картинке',
							Play: 'Воспроизведение',
							Playback: 'Воспроизведение',
							Quality: 'Качество',
							Replay: 'Повтор',
							Reset: 'Сброс',
							Seek: 'Перемотка',
							Settings: 'Настройки',
							Shadow: 'Тень',
							Size: 'Размер',
							Speed: 'Скорость',
							Text: 'Текст',
							Track: 'Трек',
							Unmute: 'Включить звук',
							Volume: 'Громкость',
							'Caption Styles': 'Стили субтитров',
							'Captions look like this': 'Субтитры выглядят так',
							'Closed-Captions Off': 'Выключить субтитры',
							'Closed-Captions On': 'Включить субтитры',
							'Display Background': 'Фон',
							'Enter Fullscreen': 'Полноэкранный режим',
							'Enter PiP': 'Картинка в картинке',
							'Exit Fullscreen': 'Выход из полноэкранного режима',
							'Exit PiP': 'Выход из картинки в картинке',
							'Google Cast': 'Google Cast',
							'Keyboard Animations': 'Анимации клавиатуры',
							'Seek Backward': 'Перемотка назад',
							'Seek Forward': 'Перемотка вперед',
							'Skip To Live': 'Перейти к прямому эфиру',
							'Text Background': 'Фон текста',
						},
						currentChapterIdx: -1,
						rafId: null,
						loading: true,
					};
				},
				methods: {
					getTimeFromUrl() {
						// Ищем ?t= или #t= в адресе
						const url = new URL(window.location.href);
						let t = url.searchParams.get('t');
						const sec = parseInt(t, 10);
						return isNaN(sec) ? 0 : sec;
					},

					async initPlayer() {
						this.loading = true;
						this.player = await VidstackPlayer.create({
							target: this.$refs.target,
							title: this.title,
							src: 'https://padatak.by/upload/video/webinars/2025/Онлайн-конференция_20.06.2025_FIN_FIX_2.mp4',
							poster: 'https://files.vidstack.io/sprite-fight/poster.webp',
							layout: new VidstackPlayerLayout({
								// thumbnails: 'https://files.vidstack.io/sprite-fight/thumbnails.vtt',
							}),
							streamType: 'on-demand',
							logLevel: 'warn',
							playsInline: true,
							tracks: [
								{
									src: './chapters (1).vtt',
									language: 'ru-RU',
									kind: 'chapters',
									type: 'vtt',
									default: true,
								},
							],
						});

						this.muted = this.player.muted;
						this.player.addEventListener('volumechange', () => {
							this.muted = this.player.muted;
						});
						this.player.addEventListener('loadedmetadata', () => {
							this.duration = this.player.duration;
						});
						if (this.player.duration) {
							this.duration = this.player.duration;
						}

						// Скрываем лоадер после полной инициализации плеера или loadedmetadata
						let loadingCleared = false;
						const clearLoading = () => {
							if (!loadingCleared) {
								this.loading = false;
								loadingCleared = true;
							}
						};
						this.player.addEventListener('loadedmetadata', clearLoading);
						// Если метаданные уже загружены (например, кэш)
						if (this.player.duration) {
							clearLoading();
						}
						// Fallback: если loadedmetadata не пришёл за 2 секунды, всё равно показываем плеер
						setTimeout(clearLoading, 2000);

						// ГЛАВЫ: слушаем появление трека и cues
						const updateChapters = () => {
							const chaptersTrack = Array.from(this.player.textTracks || []).find(
								(t) => t.kind === 'chapters'
							);
							if (chaptersTrack) {
								chaptersTrack.mode = 'hidden';
								// Ждём cues асинхронно
								const tryUpdate = () => {
									if (chaptersTrack.cues && chaptersTrack.cues.length) {
										this.chapters = Array.from(chaptersTrack.cues).map((cue) => ({
											time: cue.startTime,
											label: cue.text,
										}));
										this.updateCurrentChapter(); // Важно: сразу обновить активную главу
									} else {
										setTimeout(tryUpdate, 200); // пробуем снова через 200мс
									}
								};
								tryUpdate();
							}
						};

						// Сразу пробуем, и если что — слушаем появление новых треков
						updateChapters();
						this.player.textTracks?.addEventListener?.('addtrack', updateChapters);

						// Локализация
						const layout = document.querySelector('media-video-layout');
						if (layout) layout.translations = this.RUSSIAN;

						this.player.addEventListener('timeupdate', this.updateCurrentChapter);
						this.player.addEventListener('seeked', this.updateCurrentChapter);
						this.player.addEventListener('play', this.updateCurrentChapter);

						// Антипиратские меры: отключаем контекстное меню, выделение, drag, скачивание
						const protectVideo = () => {
							// Находим внутренний <video> элемент
							const video = this.$refs.target.querySelector('video');
							if (video) {
								video.addEventListener('contextmenu', (e) => e.preventDefault());
								video.addEventListener('dragstart', (e) => e.preventDefault());
								video.addEventListener('selectstart', (e) => e.preventDefault());
								video.setAttribute('controlsList', 'nodownload noremoteplayback');
								video.setAttribute('disablePictureInPicture', '');
								video.setAttribute('oncontextmenu', 'return false;');
								video.style.userSelect = 'none';
								video.style.pointerEvents = '';
							}
						};
						// Ждём появления <video> через MutationObserver
						const observer = new MutationObserver(() => {
							protectVideo();
						});
						observer.observe(this.$refs.target, { childList: true, subtree: true });
						// Также пробуем сразу
						setTimeout(protectVideo, 500);

						// После инициализации плеера
						const seekToUrlTime = () => {
							const sec = this.getTimeFromUrl();
							if (sec > 0 && this.player) {
								this.player.currentTime = sec;
							}
						};
						// Ждём, пока duration будет известна
						if (this.player && this.player.duration) {
							seekToUrlTime();
						} else {
							const wait = setInterval(() => {
								if (this.player && this.player.duration) {
									seekToUrlTime();
									clearInterval(wait);
								}
							}, 200);
						}
					},
					play() {
						if (this.player) this.player.play();
					},
					pause() {
						if (this.player) this.player.pause();
					},
					toggleMute() {
						if (this.player) this.player.muted = !this.player.muted;
					},
					seekTo(time) {
						if (this.player) {
							this.player.currentTime = time;
							// Немного подождать, чтобы currentTime обновился, затем обновить главу
							setTimeout(this.updateCurrentChapter, 100);
						}
					},
					formatTime(sec) {
						const h = Math.floor(sec / 3600);
						const m = Math.floor((sec % 3600) / 60);
						const s = Math.floor(sec % 60);
						if (h > 0) {
							return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
						} else {
							return `${m}:${s.toString().padStart(2, '0')}`;
						}
					},
					updateCurrentChapter() {
						if (!this.chapters.length || !this.player) {
							this.currentChapterIdx = -1;
							return;
						}
						const time = this.player.currentTime;
						let idx = -1;
						for (let i = 0; i < this.chapters.length; i++) {
							const start = this.chapters[i].time;
							const end = i < this.chapters.length - 1 ? this.chapters[i + 1].time : Infinity;
							if (time >= start && time < end) {
								idx = i;
								break;
							}
						}
						this.currentChapterIdx = idx;
					},
					startChapterRaf() {
						const loop = () => {
							this.updateCurrentChapter();
							this.rafId = requestAnimationFrame(loop);
						};
						this.rafId = requestAnimationFrame(loop);
					},
					stopChapterRaf() {
						if (this.rafId) {
							cancelAnimationFrame(this.rafId);
							this.rafId = null;
						}
					},
				},
				mounted() {
					this.initPlayer();
					this.startChapterRaf();
				},
				beforeUnmount() {
					this.stopChapterRaf();
					if (this.player) {
						this.player.removeEventListener('timeupdate', this.updateCurrentChapter);
						this.player.removeEventListener('seeked', this.updateCurrentChapter);
						this.player.removeEventListener('play', this.updateCurrentChapter);
						this.player.destroy();
					}
				},
				watch: {
					chapters() {
						this.updateCurrentChapter();
					},
				},
			},
		},
	}).mount('#app');
</script>